# 컨텍스트 배치 설계: 레이어 vs 오케스트레이터

## 범용 컨텍스트 (핵심 정의)

컨텍스트를 **"수정용 정보"에 한정하지 않고**, **이 요청에 대해 LLM이 알면 좋은 모든 정보**로 정의한다.

- **범용 컨텍스트** = 요청과 함께 오는 **키–값 형태의 정보 묶음**. 용도는 고정하지 않는다.
- **규칙:** 이 컨텍스트는 **항상** 트리 생성(및 필요 시 평가/재시도) 프롬프트에 **한 블록으로 주입**한다.
- 클라이언트(또는 서버)가 넣고 싶은 것을 자유롭게 실을 수 있고, 새 키가 생겨도 API 스키마를 바꿀 필요가 없도록 **확장 가능한 구조**로 둔다.

**예시 키 (편집 시나리오일 뿐, 전부가 아님):**

- `currentFile` — 현재 열린 파일 경로  
- `selection` — 선택된 텍스트 또는 라인 범위  
- `projectRoot` — 프로젝트 루트 (서버가 규칙 로드 등에 사용)  
- `projectRules` — 프로젝트 규칙 텍스트 (서버가 `projectRoot` 기준으로 로드해 넣을 수도 있음)  
- `gitStatus`, `openTabs`, `recentErrors` 등 — 나중에 추가해도 됨  

**데이터 형태 제안:**

- `context: Map<String, String>` — 키가 곧 라벨, 값이 내용. 프롬프트에는 예: `## 컨텍스트\ncurrentFile: src/App.kt\nselection: ...` 처럼 직렬화해서 넣는다.
- 또는 `context: List<{ key: string, value: string }>` — 순서를 보장하고 싶을 때.

**정리:**  
"컨텍스트 = 수정을 위한 몇 가지 필드"가 아니라 **"컨텍스트 = 이 요청에 대한 범용 정보 묶음, 항상 프롬프트에 밀어넣음"**으로 설계한다.

---

## API 설계: message와 context를 나누는 이유

Chat API가 `message` 하나가 아니라 **message + context**로 쪼개져 있는 이유를 설계 관점에서 정리한다.

### 1. 역할 분리 (의도 vs 환경)

- **message**: 사용자 **의도** — "이걸 해줘", "여기 수정해줘" 같은 자연어 한 덩어리. 해석은 LLM이 담당.
- **context**: 그 요청이 일어난 **환경/상태** — 어떤 파일인지, 어떤 선택인지, 어느 프로젝트인지 등. 구조화된 키–값이라 서버·레이어가 **파싱 없이** 사용 가능.

의도와 환경을 한 필드에 섞으면(예: message 안에 "현재 파일: src/App.kt. 사용자: 로그 추가해줘") 자연어 파싱에 의존하게 되고, 로케일/포맷에 취약해진다. 필드를 나누면 "무엇을 원하는지"와 "어디서/어떤 상태인지"를 항상 구분해서 쓸 수 있다.

### 2. 구조화된 정보는 구조로

- **context**는 `Map<String, String>`(또는 순서 보장 리스트)이므로:
  - 서버가 `projectRoot`만 보고 규칙 로드, `workingDirectory`만 보고 경로 해석 같은 **키 기반 처리**가 가능.
  - 클라이언트 종류(IDE, CLI, 다른 서비스)가 달라도 **같은 키**로 통신하면 되고, 새 키를 추가해도 API 스키마를 바꿀 필요가 없다.
- message는 자유 텍스트로 두고, "어디서/무엇을 기준으로" 같은 건 전부 context 쪽에 두면, 서버와 레이어 로직이 단순해진다.

### 3. 원격 레이어·다중 클라이언트와의 통신

- **오케스트레이터 ↔ 원격 레이어**에서도 "이번 호출의 사용자 문장"과 "이번 호출에 필요한 환경(projectRoot, currentFile, 작업 디렉터리 등)"을 넘겨야 한다.
- **message만** 있으면: 환경 정보를 메시지 문자열에 끼워 넣거나, 별도 프로토콜을 또 만드는 수밖에 없다.
- **message + context**로 이미 나눠 두면:
  - 같은 `ChatDto`(또는 동일한 message + context 구조)를 **사람용 클라이언트**와 **원격 레이어/다른 서비스**가 그대로 사용할 수 있고,
  - context만 그대로 전달·추가·덮어쓰기하면 되므로, "호출자가 누구든" 동일한 API 계약으로 확장 가능하다.

즉, "나중에 remote layer와도 통신하게 될 것"을 전제하면, **지금부터 message와 context를 분리해 두는 것이** 한 번의 API로 사람 클라이언트와 프로그램형 호출자(원격 레이어 포함)를 모두 수용하는 설계가 된다.

### 4. 정리

| 구분 | message | context |
|------|---------|---------|
| 의미 | 사용자 의도(자연어) | 요청이 일어난 환경/상태(구조화) |
| 소비자 | 주로 LLM(프롬프트 본문) | 서버 로직 + LLM(프롬프트 컨텍스트 블록) |
| 확장 | 문장 길이/언어만 고려 | 새 키 추가로 확장, API 스키마 변경 없음 |
| 원격 레이어 | "무엇을 해달라는지" 전달 | "어디서/무엇을 기준으로" 전달·전파 |

그래서 **단순 message 하나보다 message + context로 쪼개 두는 것이 맞고**, 원격 레이어와의 통신도 같은 계약으로 자연스럽게 이어갈 수 있다.

---

## 참고: 탑티어 에이전트(Cursor 등)의 컨텍스트 관리 — 일원화하지 않음

Cursor·Continue 등 현대 에이전트는 컨텍스트를 **한 덩어리로 일원화하지 않고**, **채널별·시점별로 나눠서** 관리한다.

### 1. 채널(소스)별 분리

- **Rules** — 프로젝트 규칙 (`.cursor/rules`, 프로젝트 전역)
- **Commands** — 슬래시 명령 (`.cursor/commands/*.md`, 작업별)
- **Skills** — 에이전트 스킬 (이름·설명은 정적, 본문은 필요 시 동적 로드)
- **@ Mentions** — 대화 중 사용자가 끌어넣는 참조 (`@code`, `@docs`, 특정 파일 등)
- **Semantic Search / Codebase** — RAG·의미 검색 결과 (요청 시점에 검색)
- **MCP / Tools** — 도구 정의는 최소한만 정적으로, 상세는 **동적 발견**(폴더/파일로 두고 에이전트가 필요 시 조회)
- **Chat history** — 대화 이력 (요약 시 이전 채팅을 “파일”로 참조해 품질 유지)
- **Terminal** — 터미널 출력을 파일로 동기화, 에이전트가 `tail`/`grep`으로 필요한 부분만 조회

각 채널은 **역할·생명주기·주입 시점**이 다르다. 한 개의 “context” 맵으로 합치지 않는다.

### 2. 정적 vs 동적

- **정적 컨텍스트** — 매 턴 항상 (또는 최소한으로) 넣는 것. 예: 시스템 지시, 도구 **이름**만, 스킬 **이름·설명**만.
- **동적 컨텍스트** — 에이전트가 **필요할 때 가져오는** 것. Cursor는 “긴 도구 응답 → 파일로 쓰고 에이전트가 읽기”, “MCP 도구 상세 → 폴더에 두고 list/grep”, “채팅 이력 → 요약 시 파일 참조”, “터미널 → 파일로 동기화 후 tail/grep” 등으로 **동적 발견(dynamic context discovery)** 을 쓴다.

그래서 토큰을 아끼고, 관련 있는 정보만 컨텍스트에 올린다.

### 3. 공통 추상: “파일”

동적으로 가져올 수 있는 것들(도구 결과, 채팅 이력, 터미널, MCP 도구 설명)을 Cursor는 **파일/폴더**로 두고, 에이전트가 `list`, `read`, `tail`, `grep` 등으로 **필요한 부분만** 끌어쓴다. “모든 컨텍스트를 한 번에 프롬프트에 넣지 않고, 파일이라는 하나의 추상으로 동적 로딩”이다.

### 4. 우리 설계와의 관계

- **지금 단계**에서 “요청과 함께 오는 정보”는 **범용 컨텍스트 맵** 하나로 받아서 프롬프트에 한 블록으로 넣는 방식이 구현 부담이 적고, 확장(키 추가)도 쉽다.
- **장기적으로**는 Cursor처럼 **채널을 나누는** 방향을 둘 수 있다.  
  - 예: `requestContext`(현재 파일·선택 등) / `projectRules`(서버가 로드) / `retrievedDocs`(RAG 결과) / `conversationSummary`(이전 턴 요약) 를 **각각 다른 블록·다른 시점**으로 프롬프트에 넣고,  
  - “동적 발견”이 필요해지면(예: 레이어 목록도 이름만 넣고 상세는 파일/도구로 조회) 그때 해당 채널만 동적화하면 된다.

즉, **일원화하지 않는 것**이 탑티어 에이전트의 공통 패턴이고, 우리는 1단계로 “요청 시점의 범용 맵”을 한 채널로 두고, 이후 채널 추가·정적/동적 분리로 점진적으로 맞춰 가면 된다.

---

## 우리 프로젝트의 컨텍스트 분리 단위

목적에 따라 컨텍스트를 **단위별로 분리**해서 관리한다. 아래는 우리 코드베이스에 맞춘 제안이다.

| 단위 | 범위 | 담을 내용 예시 |
|------|------|----------------|
| **앱 단위** | 프로세스/설정 전역 | LLM 설정(모델·티어), 기본 시스템 규칙, 로깅·메트릭, 레이어 등록 목록. "항상 이렇게 동작해라" 수준의 정적 컨텍스트. |
| **작업 트리 단위** | 한 번의 오케스트레이션 실행 | 사용자 메시지, 요청 시점의 범용 컨텍스트(현재 파일·선택·projectRoot 등), 세션/실행 ID. 트리 생성 → 실행 → 평가 → 재시도까지 **한 흐름**에서 공유하는 컨텍스트. |
| **LLM 태스크 단위** | 각 LLM 호출 종류별 | **createExecutionTree**: 사용자 요청 + requestContext + 레이어 설명. **evaluateResult**: 요청 + 실행 결과(및 요약). **suggestRetryStrategy**: 요청 + 이전 이력 + 레이어 설명. **extractParameters**: 부모 결과 + 자식 레이어/함수 정보. **compareExecutions** 등도 각자 필요한 인자만. 태스크마다 **넣는 블록·형식**을 다르게 둘 수 있음. |
| **레이어 단위** | 레이어별 | 각 레이어가 `describe()`로 제공하는 **기능 설명·함수 목록·파라미터 스키마**. 트리 생성 시 "어떤 레이어를 쓸 수 있는지" 컨텍스트. 실행 시에는 **노드 단위**(어떤 레이어·함수·args)가 곧 그 단계의 컨텍스트. |

**정리:**

- **앱** — 전역·정적.
- **작업 트리** — 한 실행 흐름 공통 (요청 + requestContext).
- **LLM 태스크** — 호출 종류별로 필요한 컨텍스트만 선택해서 프롬프트에 주입 (같은 작업 트리 안에서도 태스크마다 다른 블록).
- **레이어** — "무엇을 할 수 있는지" 설명(트리 생성용) + 실행 시 노드별 args(실행용).

이렇게 나누어 두면, 나중에 "evaluateResult에만 이전 대화 요약 넣기", "createExecutionTree에만 projectRules 블록 넣기"처럼 **목적별로 채널을 확장**하기 쉬워진다.

→ **구체적인 추상화·API·데이터 흐름**은 [context-management-design.md](./context-management-design.md) 참고 (영구/휘발성, ContextStore, AppContextService, PromptComposer, 확장 시나리오 포함).

---

## 현재 흐름 요약

```
ChatRequest(message, context?) → ChatDto(message, context) → Orchestrator.executeOrchestration(chatDto)
  → OrchestrationCoordinator: chatDto.context로 휘발성 갱신, 서버 cwd로 workingDirectory/projectRoot 자동 설정
  → refreshPersistentIfNeeded(projectRoot) → projectRules 등 영구 컨텍스트 조건부 갱신
  → createInitialTree(query, allDescriptions, appContextService, ...)
  → LLMClient.createExecutionTree(..., appContextService)
  → PromptComposer.compose(CREATE_TREE, appContextService, body)  // 영구 + 휘발 + 본문
  → LLMPromptBuilder.buildExecutionTreePrompt(userQuery, layerDescriptions) = body
  → 트리 실행 (TreeExecutor)
```

**중요:** 트리가 **생성되기 전에** LLM은 `userQuery`, `layerDescriptions`, 그리고 **영구·휘발 컨텍스트 블록**을 받는다.  
범용 컨텍스트는 요청 시 휘발성에 반영되고, 서버가 `workingDirectory`·`projectRoot`를 자동으로 넣으며, projectRoot 변경 시 영구 컨텍스트(예: projectRules)가 조건부 갱신된다. 최종 프롬프트는 **영구 + 휘발 + 본문** 순서로 조합된다.

---

## 옵션 A: 컨텍스트를 오케스트레이터(요청 스코프)에 둠

### 개념

- **범용 컨텍스트**는 요청과 함께 오는 입력이며, `Map<String, String>`(또는 순서 보장 리스트) 형태로 둔다.
- 클라이언트가 `POST /chat` 시 `message` 외에 `context: { "currentFile": "...", "selection": "...", ... }` 를 보낸다. 키는 고정이 아니며, `gitStatus`, `openTabs` 등 나중에 무엇이든 추가 가능.
- 오케스트레이터가 이 맵을 받아 **트리 생성(및 평가/재시도) 단계**에 넘긴다.
- `LLMPromptBuilder.buildExecutionTreePrompt(..., context)` 에서 **context가 비어 있지 않으면** 프롬프트에 **항상** `## 컨텍스트` 블록을 넣고, 각 키–값을 읽기 쉬운 형태로 직렬화(예: `키: 값` 한 줄씩)한다.
- 서버가 채울 수 있는 항목(예: 프로젝트 규칙)은, `context`에 `projectRoot`가 있으면 규칙 로더가 `.cursor/rules` 등을 읽어 `projectRules`로 같은 맵에 넣거나, 별도 블록으로 프롬프트에 추가할 수 있다.

### 장점

- **시점이 맞음:** 트리를 만들 때 필요한 정보를 그대로 쓴다. “트리 실행 중에 컨텍스트를 가져오는” 추가 단계가 없다.
- **레이어 의미 유지:** 레이어는 “실행할 수 있는 작업”(파일 읽기, 빌드, grep 등)만 담당하고, “요청 시점의 편집 상태”는 레이어가 아니다.
- **구현 단순:** DTO·API·프롬프트 빌더만 확장하면 된다. 새 레이어나 실행 경로가 필요 없다.
- **원격/분산과 잘 맞음:** 다른 오케스트레이터 인스턴스가 있어도, 요청에 실린 컨텍스트만 전달하면 동일하게 동작한다.

### 단점

- 오케스트레이터(또는 진입점)가 “컨텍스트를 받고, 규칙을 로드하고, 프롬프트에 넣는” 책임을 가진다. (규칙 로딩을 작은 서비스로 분리하면 부담은 줄어든다.)

### 데이터 흐름

```
[클라이언트] message, context?: Map<String, String>  (예: currentFile, selection, projectRoot, …)
    → ChatRequest / ChatDto: message + context
    → executeOrchestration(chatDto)  // chatDto.context 가 있으면 항상 프롬프트에 주입
    → createInitialTree(..., context)
    → LLMClient.createExecutionTree(userQuery, layerDescriptions, context)
    → LLMPromptBuilder: context 비어 있지 않으면 항상 "## 컨텍스트" 블록 추가
```

---

## 옵션 B: 컨텍스트를 레이어로 둠 (ContextLayer)

### 개념

- “현재 파일”, “선택 영역”, “프로젝트 규칙”을 반환하는 **ContextLayer**를 만든다.
- 트리 실행 시 이 레이어의 `getCurrentFile()`, `getSelection()`, `getProjectRules(projectRoot)` 같은 노드가 실행되어, 그 결과를 이후 노드(예: LLM, 파일 수정)의 인자로 쓴다.

### 문제점

1. **시점 불일치**  
   트리를 **만들 때** LLM이 “어떤 파일을 수정할지”를 알아야 하는데, 그 정보는 **트리가 실행된 뒤** ContextLayer 노드를 돌려야 얻을 수 있다.  
   → 트리 생성 단계에는 여전히 “현재 파일/선택”이 없음.  
   → 해결하려면 “1단계: 컨텍스트만 가져오는 트리 실행 → 2단계: 그 결과를 넣어서 실제 트리 생성”처럼 **두 번의 트리 생성/실행**이 필요해짐.

2. **컨텍스트 값의 출처**  
   ContextLayer가 반환할 값은 결국 **클라이언트가 보낸 값**이어야 한다.  
   서버가 스스로 “현재 파일”을 알 수 없으므로, 클라이언트가 `POST /context` 같은 API로 미리 넣어 두거나, 요청과 함께 보내야 한다.  
   그렇다면 “요청 시 컨텍스트를 받아서 쓰는” 것은 동일하고, 레이어는 “그걸 실행 중에 한 번 더 꺼내 쓰는 역할”만 하게 됨 → 중복.

3. **프로젝트 규칙**  
   `getProjectRules(projectRoot)`는 실행 시점에 디스크를 읽으면 되므로 레이어로 두는 것도 가능하다.  
   하지만 “트리 생성 시 규칙을 참고해서 계획을 세워라”가 목적이면, 역시 **트리 생성 전**에 규칙이 프롬프트에 있어야 해서, 규칙만큼은 오케스트레이터(또는 규칙 로더)가 먼저 읽어서 프롬프트에 넣는 편이 자연스럽다.

### 레이어로 두었을 때 가능한 형태

- “트리 생성 시점”에는 여전히 **요청에 실린 컨텍스트**를 프롬프트에 넣고,
- “실행 중에” 동적으로 프로젝트 규칙을 읽거나, 세션에 저장된 컨텍스트를 노드가 조회하는 **보조 수단**으로만 ContextLayer를 둘 수는 있다.  
- 다만 “현재 파일/선택”은 트리 생성에 필수이므로, 레이어만으로는 부족하고 오케스트레이터 쪽 입력이 반드시 필요하다.

---

## 옵션 C: 하이브리드 (권장)

- **오케스트레이터(요청 스코프):**
  - `currentFile`, `selection`, `projectRoot`는 **항상** 요청과 함께 API로 전달.
  - 트리 생성 시 이 값들을 `LLMPromptBuilder`에 넘겨 프롬프트에 포함.
  - 프로젝트 규칙은 `projectRoot`가 있으면 오케스트레이터(또는 전용 규칙 로더)가 `.cursor/rules` 등을 읽어 프롬프트에 넣음.
- **레이어:**
  - 컨텍스트를 “실행 중에 조회하는” 레이어는 **선택 사항**으로 둠.  
    예: 나중에 “실행 중에 git 상태를 보고 싶다” 같은 요구가 생기면, **GitContextLayer**처럼 “실행 시점 정보”를 제공하는 레이어를 별도로 추가.  
  - “현재 파일/선택”은 레이어가 아니라 요청 스코프로만 다룸.

이렇게 하면:

- 트리 생성에 필요한 컨텍스트는 **오케스트레이터**에서만 다루고,
- “실행 중에만 의미 있는 컨텍스트”(git, 최근 수정 파일 등)는 필요 시 **레이어**로 확장할 수 있다.

---

## 결론 및 권장

| 항목 | 레이어 | 오케스트레이터(요청 스코프) |
|------|--------|-----------------------------|
| 현재 파일 / 선택 영역 | 트리 생성 전에 필요해서 시점 맞지 않음; 결국 클라이언트가 보낸 값을 저장해 두었다가 반환하는 역할만 가능 | 요청과 함께 받아 트리 생성 프롬프트에 바로 사용 가능 |
| 프로젝트 규칙 | 실행 중에 읽을 수는 있으나, “계획 수립 시 참고”가 목적이면 트리 생성 전에 필요 | projectRoot 기준으로 규칙 로드 후 프롬프트에 포함하기 적합 |
| 구현 복잡도 | 이중 트리 생성 또는 세션 저장 + 레이어 상태 유지 필요 | DTO·API·프롬프트 확장으로 해결 |

**권장:**  
컨텍스트(현재 파일, 선택, projectRoot, 프로젝트 규칙)는 **오케스트레이터에 두고**, 요청 스코프의 입력으로만 다루는 것을 기본으로 하고,  
“실행 중에만 필요한 컨텍스트”는 필요할 때 별도 레이어(Git 등)로 추가하는 **옵션 C(하이브리드)** 를 추천한다.

이렇게 정한 뒤, 1순위 구현(채팅/실행 API 확장, DTO 확장, 프롬프트에 컨텍스트 주입, 프로젝트 규칙 로딩)을 진행하면 된다.
